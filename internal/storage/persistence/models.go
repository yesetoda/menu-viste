// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package persistence

import (
	"database/sql/driver"
	"fmt"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type InvoiceStatus string

const (
	InvoiceStatusPending  InvoiceStatus = "pending"
	InvoiceStatusPaid     InvoiceStatus = "paid"
	InvoiceStatusFailed   InvoiceStatus = "failed"
	InvoiceStatusRefunded InvoiceStatus = "refunded"
)

func (e *InvoiceStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InvoiceStatus(s)
	case string:
		*e = InvoiceStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for InvoiceStatus: %T", src)
	}
	return nil
}

type NullInvoiceStatus struct {
	InvoiceStatus InvoiceStatus `json:"invoice_status"`
	Valid         bool          `json:"valid"` // Valid is true if InvoiceStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInvoiceStatus) Scan(value interface{}) error {
	if value == nil {
		ns.InvoiceStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InvoiceStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInvoiceStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InvoiceStatus), nil
}

type RestaurantStatus string

const (
	RestaurantStatusPending   RestaurantStatus = "pending"
	RestaurantStatusApproved  RestaurantStatus = "approved"
	RestaurantStatusRejected  RestaurantStatus = "rejected"
	RestaurantStatusSuspended RestaurantStatus = "suspended"
)

func (e *RestaurantStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RestaurantStatus(s)
	case string:
		*e = RestaurantStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for RestaurantStatus: %T", src)
	}
	return nil
}

type NullRestaurantStatus struct {
	RestaurantStatus RestaurantStatus `json:"restaurant_status"`
	Valid            bool             `json:"valid"` // Valid is true if RestaurantStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRestaurantStatus) Scan(value interface{}) error {
	if value == nil {
		ns.RestaurantStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RestaurantStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRestaurantStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RestaurantStatus), nil
}

type SubscriptionStatus string

const (
	SubscriptionStatusActive     SubscriptionStatus = "active"
	SubscriptionStatusCancelled  SubscriptionStatus = "cancelled"
	SubscriptionStatusPastDue    SubscriptionStatus = "past_due"
	SubscriptionStatusTrialing   SubscriptionStatus = "trialing"
	SubscriptionStatusIncomplete SubscriptionStatus = "incomplete"
	SubscriptionStatusUpdated    SubscriptionStatus = "updated"
)

func (e *SubscriptionStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SubscriptionStatus(s)
	case string:
		*e = SubscriptionStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for SubscriptionStatus: %T", src)
	}
	return nil
}

type NullSubscriptionStatus struct {
	SubscriptionStatus SubscriptionStatus `json:"subscription_status"`
	Valid              bool               `json:"valid"` // Valid is true if SubscriptionStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSubscriptionStatus) Scan(value interface{}) error {
	if value == nil {
		ns.SubscriptionStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SubscriptionStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSubscriptionStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SubscriptionStatus), nil
}

type UserRole string

const (
	UserRoleAdmin UserRole = "admin"
	UserRoleOwner UserRole = "owner"
	UserRoleStaff UserRole = "staff"
)

func (e *UserRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserRole(s)
	case string:
		*e = UserRole(s)
	default:
		return fmt.Errorf("unsupported scan type for UserRole: %T", src)
	}
	return nil
}

type NullUserRole struct {
	UserRole UserRole `json:"user_role"`
	Valid    bool     `json:"valid"` // Valid is true if UserRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserRole) Scan(value interface{}) error {
	if value == nil {
		ns.UserRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserRole), nil
}

type ActivityLog struct {
	ID             uuid.UUID        `db:"id" json:"id"`
	RestaurantID   uuid.UUID        `db:"restaurant_id" json:"restaurant_id"`
	UserID         uuid.UUID        `db:"user_id" json:"user_id"`
	ActionType     string           `db:"action_type" json:"action_type"`
	ActionCategory string           `db:"action_category" json:"action_category"`
	Description    pgtype.Text      `db:"description" json:"description"`
	TargetType     pgtype.Text      `db:"target_type" json:"target_type"`
	TargetID       *uuid.UUID       `db:"target_id" json:"target_id"`
	TargetName     pgtype.Text      `db:"target_name" json:"target_name"`
	BeforeValue    []byte           `db:"before_value" json:"before_value"`
	AfterValue     []byte           `db:"after_value" json:"after_value"`
	IpAddress      pgtype.Text      `db:"ip_address" json:"ip_address"`
	UserAgent      pgtype.Text      `db:"user_agent" json:"user_agent"`
	DeviceType     pgtype.Text      `db:"device_type" json:"device_type"`
	Browser        pgtype.Text      `db:"browser" json:"browser"`
	Os             pgtype.Text      `db:"os" json:"os"`
	Success        pgtype.Bool      `db:"success" json:"success"`
	CreatedAt      pgtype.Timestamp `db:"created_at" json:"created_at"`
}

type AnalyticsAggregate struct {
	ID           uuid.UUID        `db:"id" json:"id"`
	RestaurantID uuid.UUID        `db:"restaurant_id" json:"restaurant_id"`
	Date         pgtype.Date      `db:"date" json:"date"`
	Hour         pgtype.Int4      `db:"hour" json:"hour"`
	MetricType   string           `db:"metric_type" json:"metric_type"`
	TargetID     *uuid.UUID       `db:"target_id" json:"target_id"`
	Value        pgtype.Int4      `db:"value" json:"value"`
	CreatedAt    pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt    pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type AnalyticsEvent struct {
	ID           uuid.UUID        `db:"id" json:"id"`
	RestaurantID uuid.UUID        `db:"restaurant_id" json:"restaurant_id"`
	EventType    string           `db:"event_type" json:"event_type"`
	VisitorID    string           `db:"visitor_id" json:"visitor_id"`
	SessionID    uuid.UUID        `db:"session_id" json:"session_id"`
	TargetID     *uuid.UUID       `db:"target_id" json:"target_id"`
	IpAddress    pgtype.Text      `db:"ip_address" json:"ip_address"`
	DeviceType   pgtype.Text      `db:"device_type" json:"device_type"`
	Browser      pgtype.Text      `db:"browser" json:"browser"`
	Os           pgtype.Text      `db:"os" json:"os"`
	Country      pgtype.Text      `db:"country" json:"country"`
	City         pgtype.Text      `db:"city" json:"city"`
	CreatedAt    pgtype.Timestamp `db:"created_at" json:"created_at"`
}

type Category struct {
	ID           uuid.UUID        `db:"id" json:"id"`
	RestaurantID uuid.UUID        `db:"restaurant_id" json:"restaurant_id"`
	Name         string           `db:"name" json:"name"`
	Description  pgtype.Text      `db:"description" json:"description"`
	Icon         pgtype.Text      `db:"icon" json:"icon"`
	DisplayOrder int32            `db:"display_order" json:"display_order"`
	IsActive     bool             `db:"is_active" json:"is_active"`
	CreatedBy    uuid.UUID        `db:"created_by" json:"created_by"`
	CreatedAt    pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt    pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type Invoice struct {
	ID                       uuid.UUID        `db:"id" json:"id"`
	SubscriptionID           uuid.UUID        `db:"subscription_id" json:"subscription_id"`
	OwnerID                  uuid.UUID        `db:"owner_id" json:"owner_id"`
	InvoiceNumber            string           `db:"invoice_number" json:"invoice_number"`
	Amount                   pgtype.Numeric   `db:"amount" json:"amount"`
	Currency                 string           `db:"currency" json:"currency"`
	Status                   InvoiceStatus    `db:"status" json:"status"`
	BillingPeriodStart       pgtype.Timestamp `db:"billing_period_start" json:"billing_period_start"`
	BillingPeriodEnd         pgtype.Timestamp `db:"billing_period_end" json:"billing_period_end"`
	PaymentProviderInvoiceID pgtype.Text      `db:"payment_provider_invoice_id" json:"payment_provider_invoice_id"`
	PaidAt                   pgtype.Timestamp `db:"paid_at" json:"paid_at"`
	CreatedAt                pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt                pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type MenuItem struct {
	ID           uuid.UUID        `db:"id" json:"id"`
	RestaurantID uuid.UUID        `db:"restaurant_id" json:"restaurant_id"`
	CategoryID   uuid.UUID        `db:"category_id" json:"category_id"`
	Name         string           `db:"name" json:"name"`
	Description  pgtype.Text      `db:"description" json:"description"`
	Price        pgtype.Numeric   `db:"price" json:"price"`
	Currency     string           `db:"currency" json:"currency"`
	Images       []byte           `db:"images" json:"images"`
	Allergens    []byte           `db:"allergens" json:"allergens"`
	DietaryTags  []byte           `db:"dietary_tags" json:"dietary_tags"`
	SpiceLevel   pgtype.Int4      `db:"spice_level" json:"spice_level"`
	Calories     pgtype.Int4      `db:"calories" json:"calories"`
	IsAvailable  bool             `db:"is_available" json:"is_available"`
	DisplayOrder int32            `db:"display_order" json:"display_order"`
	ViewCount    pgtype.Int4      `db:"view_count" json:"view_count"`
	CreatedBy    uuid.UUID        `db:"created_by" json:"created_by"`
	CreatedAt    pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt    pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type PaymentRetryJob struct {
	ID             uuid.UUID        `db:"id" json:"id"`
	SubscriptionID uuid.UUID        `db:"subscription_id" json:"subscription_id"`
	Status         string           `db:"status" json:"status"`
	RetryCount     pgtype.Int4      `db:"retry_count" json:"retry_count"`
	MaxRetries     pgtype.Int4      `db:"max_retries" json:"max_retries"`
	ScheduledFor   pgtype.Timestamp `db:"scheduled_for" json:"scheduled_for"`
	CreatedAt      pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt      pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type PaymentTransaction struct {
	ID                     uuid.UUID        `db:"id" json:"id"`
	OwnerID                uuid.UUID        `db:"owner_id" json:"owner_id"`
	Amount                 pgtype.Numeric   `db:"amount" json:"amount"`
	Currency               string           `db:"currency" json:"currency"`
	Status                 string           `db:"status" json:"status"`
	TxRef                  string           `db:"tx_ref" json:"tx_ref"`
	Reference              pgtype.Text      `db:"reference" json:"reference"`
	ProviderTransactionRef pgtype.Text      `db:"provider_transaction_ref" json:"provider_transaction_ref"`
	CreatedAt              pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt              pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type PaymentWebhook struct {
	ID              uuid.UUID        `db:"id" json:"id"`
	ProviderEventID pgtype.Text      `db:"provider_event_id" json:"provider_event_id"`
	EventType       string           `db:"event_type" json:"event_type"`
	Payload         []byte           `db:"payload" json:"payload"`
	Processed       pgtype.Bool      `db:"processed" json:"processed"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
}

type Restaurant struct {
	ID            uuid.UUID        `db:"id" json:"id"`
	OwnerID       uuid.UUID        `db:"owner_id" json:"owner_id"`
	Name          string           `db:"name" json:"name"`
	Slug          string           `db:"slug" json:"slug"`
	Description   pgtype.Text      `db:"description" json:"description"`
	CuisineType   pgtype.Text      `db:"cuisine_type" json:"cuisine_type"`
	Phone         pgtype.Text      `db:"phone" json:"phone"`
	Email         pgtype.Text      `db:"email" json:"email"`
	Website       pgtype.Text      `db:"website" json:"website"`
	Address       pgtype.Text      `db:"address" json:"address"`
	City          pgtype.Text      `db:"city" json:"city"`
	Country       pgtype.Text      `db:"country" json:"country"`
	LogoUrl       pgtype.Text      `db:"logo_url" json:"logo_url"`
	CoverImageUrl pgtype.Text      `db:"cover_image_url" json:"cover_image_url"`
	ThemeSettings []byte           `db:"theme_settings" json:"theme_settings"`
	IsPublished   bool             `db:"is_published" json:"is_published"`
	ViewCount     pgtype.Int4      `db:"view_count" json:"view_count"`
	RankScore     pgtype.Numeric   `db:"rank_score" json:"rank_score"`
	CreatedAt     pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt     pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type Subscription struct {
	ID                            uuid.UUID          `db:"id" json:"id"`
	OwnerID                       uuid.UUID          `db:"owner_id" json:"owner_id"`
	PlanID                        uuid.UUID          `db:"plan_id" json:"plan_id"`
	Status                        SubscriptionStatus `db:"status" json:"status"`
	CurrentPeriodStart            pgtype.Timestamp   `db:"current_period_start" json:"current_period_start"`
	CurrentPeriodEnd              pgtype.Timestamp   `db:"current_period_end" json:"current_period_end"`
	TrialEnd                      pgtype.Timestamp   `db:"trial_end" json:"trial_end"`
	CancelledAt                   pgtype.Timestamp   `db:"cancelled_at" json:"cancelled_at"`
	PaymentProviderSubscriptionID pgtype.Text        `db:"payment_provider_subscription_id" json:"payment_provider_subscription_id"`
	CreatedAt                     pgtype.Timestamp   `db:"created_at" json:"created_at"`
	UpdatedAt                     pgtype.Timestamp   `db:"updated_at" json:"updated_at"`
}

type SubscriptionPlan struct {
	ID           uuid.UUID        `db:"id" json:"id"`
	Name         string           `db:"name" json:"name"`
	Slug         string           `db:"slug" json:"slug"`
	Description  pgtype.Text      `db:"description" json:"description"`
	PriceMonthly int32            `db:"price_monthly" json:"price_monthly"`
	PriceAnnual  pgtype.Int4      `db:"price_annual" json:"price_annual"`
	Currency     string           `db:"currency" json:"currency"`
	Features     []byte           `db:"features" json:"features"`
	DisplayOrder int32            `db:"display_order" json:"display_order"`
	IsActive     bool             `db:"is_active" json:"is_active"`
	CreatedAt    pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt    pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type User struct {
	ID                         uuid.UUID        `db:"id" json:"id"`
	Email                      string           `db:"email" json:"email"`
	PasswordHash               string           `db:"password_hash" json:"password_hash"`
	FullName                   string           `db:"full_name" json:"full_name"`
	Role                       UserRole         `db:"role" json:"role"`
	OwnerID                    *uuid.UUID       `db:"owner_id" json:"owner_id"`
	RestaurantID               *uuid.UUID       `db:"restaurant_id" json:"restaurant_id"`
	Phone                      pgtype.Text      `db:"phone" json:"phone"`
	AvatarUrl                  pgtype.Text      `db:"avatar_url" json:"avatar_url"`
	EmailVerified              bool             `db:"email_verified" json:"email_verified"`
	LastLoginAt                pgtype.Timestamp `db:"last_login_at" json:"last_login_at"`
	IsActive                   bool             `db:"is_active" json:"is_active"`
	CreatedAt                  pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt                  pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	EmailVerifiedAt            pgtype.Timestamp `db:"email_verified_at" json:"email_verified_at"`
	VerificationToken          pgtype.Text      `db:"verification_token" json:"verification_token"`
	VerificationTokenExpiresAt pgtype.Timestamp `db:"verification_token_expires_at" json:"verification_token_expires_at"`
	TrialEndsAt                pgtype.Timestamp `db:"trial_ends_at" json:"trial_ends_at"`
}
