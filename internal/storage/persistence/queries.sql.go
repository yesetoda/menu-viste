// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package persistence

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createActivityLog = `-- name: CreateActivityLog :one
INSERT INTO activity_logs (
    restaurant_id, user_id, action_type, action_category, description, target_type, target_id, target_name, before_value, after_value, ip_address, user_agent, device_type, browser, os, success
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16
) RETURNING id, restaurant_id, user_id, action_type, action_category, description, target_type, target_id, target_name, before_value, after_value, ip_address, user_agent, device_type, browser, os, success, created_at
`

type CreateActivityLogParams struct {
	RestaurantID   uuid.UUID   `db:"restaurant_id" json:"restaurant_id"`
	UserID         uuid.UUID   `db:"user_id" json:"user_id"`
	ActionType     string      `db:"action_type" json:"action_type"`
	ActionCategory string      `db:"action_category" json:"action_category"`
	Description    pgtype.Text `db:"description" json:"description"`
	TargetType     pgtype.Text `db:"target_type" json:"target_type"`
	TargetID       *uuid.UUID  `db:"target_id" json:"target_id"`
	TargetName     pgtype.Text `db:"target_name" json:"target_name"`
	BeforeValue    []byte      `db:"before_value" json:"before_value"`
	AfterValue     []byte      `db:"after_value" json:"after_value"`
	IpAddress      pgtype.Text `db:"ip_address" json:"ip_address"`
	UserAgent      pgtype.Text `db:"user_agent" json:"user_agent"`
	DeviceType     pgtype.Text `db:"device_type" json:"device_type"`
	Browser        pgtype.Text `db:"browser" json:"browser"`
	Os             pgtype.Text `db:"os" json:"os"`
	Success        pgtype.Bool `db:"success" json:"success"`
}

func (q *Queries) CreateActivityLog(ctx context.Context, arg CreateActivityLogParams) (ActivityLog, error) {
	row := q.db.QueryRow(ctx, createActivityLog,
		arg.RestaurantID,
		arg.UserID,
		arg.ActionType,
		arg.ActionCategory,
		arg.Description,
		arg.TargetType,
		arg.TargetID,
		arg.TargetName,
		arg.BeforeValue,
		arg.AfterValue,
		arg.IpAddress,
		arg.UserAgent,
		arg.DeviceType,
		arg.Browser,
		arg.Os,
		arg.Success,
	)
	var i ActivityLog
	err := row.Scan(
		&i.ID,
		&i.RestaurantID,
		&i.UserID,
		&i.ActionType,
		&i.ActionCategory,
		&i.Description,
		&i.TargetType,
		&i.TargetID,
		&i.TargetName,
		&i.BeforeValue,
		&i.AfterValue,
		&i.IpAddress,
		&i.UserAgent,
		&i.DeviceType,
		&i.Browser,
		&i.Os,
		&i.Success,
		&i.CreatedAt,
	)
	return i, err
}

const createAnalyticsEvent = `-- name: CreateAnalyticsEvent :one
INSERT INTO analytics_events (
    restaurant_id, event_type, visitor_id, session_id, target_id, ip_address, device_type, browser, os, country, city
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, restaurant_id, event_type, visitor_id, session_id, target_id, ip_address, device_type, browser, os, country, city, created_at
`

type CreateAnalyticsEventParams struct {
	RestaurantID uuid.UUID   `db:"restaurant_id" json:"restaurant_id"`
	EventType    string      `db:"event_type" json:"event_type"`
	VisitorID    string      `db:"visitor_id" json:"visitor_id"`
	SessionID    uuid.UUID   `db:"session_id" json:"session_id"`
	TargetID     *uuid.UUID  `db:"target_id" json:"target_id"`
	IpAddress    pgtype.Text `db:"ip_address" json:"ip_address"`
	DeviceType   pgtype.Text `db:"device_type" json:"device_type"`
	Browser      pgtype.Text `db:"browser" json:"browser"`
	Os           pgtype.Text `db:"os" json:"os"`
	Country      pgtype.Text `db:"country" json:"country"`
	City         pgtype.Text `db:"city" json:"city"`
}

func (q *Queries) CreateAnalyticsEvent(ctx context.Context, arg CreateAnalyticsEventParams) (AnalyticsEvent, error) {
	row := q.db.QueryRow(ctx, createAnalyticsEvent,
		arg.RestaurantID,
		arg.EventType,
		arg.VisitorID,
		arg.SessionID,
		arg.TargetID,
		arg.IpAddress,
		arg.DeviceType,
		arg.Browser,
		arg.Os,
		arg.Country,
		arg.City,
	)
	var i AnalyticsEvent
	err := row.Scan(
		&i.ID,
		&i.RestaurantID,
		&i.EventType,
		&i.VisitorID,
		&i.SessionID,
		&i.TargetID,
		&i.IpAddress,
		&i.DeviceType,
		&i.Browser,
		&i.Os,
		&i.Country,
		&i.City,
		&i.CreatedAt,
	)
	return i, err
}

const createCategory = `-- name: CreateCategory :one
INSERT INTO categories (
    restaurant_id, name, description, icon, display_order, is_active, created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, restaurant_id, name, description, icon, display_order, is_active, created_by, created_at, updated_at
`

type CreateCategoryParams struct {
	RestaurantID uuid.UUID   `db:"restaurant_id" json:"restaurant_id"`
	Name         string      `db:"name" json:"name"`
	Description  pgtype.Text `db:"description" json:"description"`
	Icon         pgtype.Text `db:"icon" json:"icon"`
	DisplayOrder int32       `db:"display_order" json:"display_order"`
	IsActive     bool        `db:"is_active" json:"is_active"`
	CreatedBy    uuid.UUID   `db:"created_by" json:"created_by"`
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (Category, error) {
	row := q.db.QueryRow(ctx, createCategory,
		arg.RestaurantID,
		arg.Name,
		arg.Description,
		arg.Icon,
		arg.DisplayOrder,
		arg.IsActive,
		arg.CreatedBy,
	)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.RestaurantID,
		&i.Name,
		&i.Description,
		&i.Icon,
		&i.DisplayOrder,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createInvoice = `-- name: CreateInvoice :one
INSERT INTO invoices (
    subscription_id, owner_id, invoice_number, amount, currency, status, billing_period_start, billing_period_end
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, subscription_id, owner_id, invoice_number, amount, currency, status, billing_period_start, billing_period_end, payment_provider_invoice_id, paid_at, created_at, updated_at
`

type CreateInvoiceParams struct {
	SubscriptionID     uuid.UUID        `db:"subscription_id" json:"subscription_id"`
	OwnerID            uuid.UUID        `db:"owner_id" json:"owner_id"`
	InvoiceNumber      string           `db:"invoice_number" json:"invoice_number"`
	Amount             pgtype.Numeric   `db:"amount" json:"amount"`
	Currency           string           `db:"currency" json:"currency"`
	Status             InvoiceStatus    `db:"status" json:"status"`
	BillingPeriodStart pgtype.Timestamp `db:"billing_period_start" json:"billing_period_start"`
	BillingPeriodEnd   pgtype.Timestamp `db:"billing_period_end" json:"billing_period_end"`
}

func (q *Queries) CreateInvoice(ctx context.Context, arg CreateInvoiceParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, createInvoice,
		arg.SubscriptionID,
		arg.OwnerID,
		arg.InvoiceNumber,
		arg.Amount,
		arg.Currency,
		arg.Status,
		arg.BillingPeriodStart,
		arg.BillingPeriodEnd,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.OwnerID,
		&i.InvoiceNumber,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.BillingPeriodStart,
		&i.BillingPeriodEnd,
		&i.PaymentProviderInvoiceID,
		&i.PaidAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createMenuItem = `-- name: CreateMenuItem :one
INSERT INTO menu_items (
    restaurant_id, category_id, name, description, price, currency, images, allergens, dietary_tags, spice_level, calories, is_available, display_order, created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
) RETURNING id, restaurant_id, category_id, name, description, price, currency, images, allergens, dietary_tags, spice_level, calories, is_available, display_order, view_count, created_by, created_at, updated_at
`

type CreateMenuItemParams struct {
	RestaurantID uuid.UUID      `db:"restaurant_id" json:"restaurant_id"`
	CategoryID   uuid.UUID      `db:"category_id" json:"category_id"`
	Name         string         `db:"name" json:"name"`
	Description  pgtype.Text    `db:"description" json:"description"`
	Price        pgtype.Numeric `db:"price" json:"price"`
	Currency     string         `db:"currency" json:"currency"`
	Images       []byte         `db:"images" json:"images"`
	Allergens    []byte         `db:"allergens" json:"allergens"`
	DietaryTags  []byte         `db:"dietary_tags" json:"dietary_tags"`
	SpiceLevel   pgtype.Int4    `db:"spice_level" json:"spice_level"`
	Calories     pgtype.Int4    `db:"calories" json:"calories"`
	IsAvailable  bool           `db:"is_available" json:"is_available"`
	DisplayOrder int32          `db:"display_order" json:"display_order"`
	CreatedBy    uuid.UUID      `db:"created_by" json:"created_by"`
}

func (q *Queries) CreateMenuItem(ctx context.Context, arg CreateMenuItemParams) (MenuItem, error) {
	row := q.db.QueryRow(ctx, createMenuItem,
		arg.RestaurantID,
		arg.CategoryID,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.Currency,
		arg.Images,
		arg.Allergens,
		arg.DietaryTags,
		arg.SpiceLevel,
		arg.Calories,
		arg.IsAvailable,
		arg.DisplayOrder,
		arg.CreatedBy,
	)
	var i MenuItem
	err := row.Scan(
		&i.ID,
		&i.RestaurantID,
		&i.CategoryID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.Currency,
		&i.Images,
		&i.Allergens,
		&i.DietaryTags,
		&i.SpiceLevel,
		&i.Calories,
		&i.IsAvailable,
		&i.DisplayOrder,
		&i.ViewCount,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPaymentRetryJob = `-- name: CreatePaymentRetryJob :one
INSERT INTO payment_retry_jobs (
    subscription_id, scheduled_for
) VALUES (
    $1, $2
) RETURNING id, subscription_id, status, retry_count, max_retries, scheduled_for, created_at, updated_at
`

type CreatePaymentRetryJobParams struct {
	SubscriptionID uuid.UUID        `db:"subscription_id" json:"subscription_id"`
	ScheduledFor   pgtype.Timestamp `db:"scheduled_for" json:"scheduled_for"`
}

func (q *Queries) CreatePaymentRetryJob(ctx context.Context, arg CreatePaymentRetryJobParams) (PaymentRetryJob, error) {
	row := q.db.QueryRow(ctx, createPaymentRetryJob, arg.SubscriptionID, arg.ScheduledFor)
	var i PaymentRetryJob
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.Status,
		&i.RetryCount,
		&i.MaxRetries,
		&i.ScheduledFor,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPaymentTransaction = `-- name: CreatePaymentTransaction :one
INSERT INTO payment_transactions (
    owner_id, amount, currency, status, tx_ref, reference
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, owner_id, amount, currency, status, tx_ref, reference, provider_transaction_ref, created_at, updated_at
`

type CreatePaymentTransactionParams struct {
	OwnerID   uuid.UUID      `db:"owner_id" json:"owner_id"`
	Amount    pgtype.Numeric `db:"amount" json:"amount"`
	Currency  string         `db:"currency" json:"currency"`
	Status    string         `db:"status" json:"status"`
	TxRef     string         `db:"tx_ref" json:"tx_ref"`
	Reference pgtype.Text    `db:"reference" json:"reference"`
}

func (q *Queries) CreatePaymentTransaction(ctx context.Context, arg CreatePaymentTransactionParams) (PaymentTransaction, error) {
	row := q.db.QueryRow(ctx, createPaymentTransaction,
		arg.OwnerID,
		arg.Amount,
		arg.Currency,
		arg.Status,
		arg.TxRef,
		arg.Reference,
	)
	var i PaymentTransaction
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.TxRef,
		&i.Reference,
		&i.ProviderTransactionRef,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPaymentWebhook = `-- name: CreatePaymentWebhook :one
INSERT INTO payment_webhooks (
    provider_event_id, event_type, payload
) VALUES (
    $1, $2, $3
) ON CONFLICT (provider_event_id) DO NOTHING
RETURNING id, provider_event_id, event_type, payload, processed, created_at
`

type CreatePaymentWebhookParams struct {
	ProviderEventID pgtype.Text `db:"provider_event_id" json:"provider_event_id"`
	EventType       string      `db:"event_type" json:"event_type"`
	Payload         []byte      `db:"payload" json:"payload"`
}

func (q *Queries) CreatePaymentWebhook(ctx context.Context, arg CreatePaymentWebhookParams) (PaymentWebhook, error) {
	row := q.db.QueryRow(ctx, createPaymentWebhook, arg.ProviderEventID, arg.EventType, arg.Payload)
	var i PaymentWebhook
	err := row.Scan(
		&i.ID,
		&i.ProviderEventID,
		&i.EventType,
		&i.Payload,
		&i.Processed,
		&i.CreatedAt,
	)
	return i, err
}

const createRestaurant = `-- name: CreateRestaurant :one
INSERT INTO restaurants (
    owner_id, name, slug, description, cuisine_type, phone, email, website, address, city, country, logo_url, cover_image_url, theme_settings
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
) RETURNING id, owner_id, name, slug, description, cuisine_type, phone, email, website, address, city, country, logo_url, cover_image_url, theme_settings, is_published,  view_count, rank_score, created_at, updated_at
`

type CreateRestaurantParams struct {
	OwnerID       uuid.UUID   `db:"owner_id" json:"owner_id"`
	Name          string      `db:"name" json:"name"`
	Slug          string      `db:"slug" json:"slug"`
	Description   pgtype.Text `db:"description" json:"description"`
	CuisineType   pgtype.Text `db:"cuisine_type" json:"cuisine_type"`
	Phone         pgtype.Text `db:"phone" json:"phone"`
	Email         pgtype.Text `db:"email" json:"email"`
	Website       pgtype.Text `db:"website" json:"website"`
	Address       pgtype.Text `db:"address" json:"address"`
	City          pgtype.Text `db:"city" json:"city"`
	Country       pgtype.Text `db:"country" json:"country"`
	LogoUrl       pgtype.Text `db:"logo_url" json:"logo_url"`
	CoverImageUrl pgtype.Text `db:"cover_image_url" json:"cover_image_url"`
	ThemeSettings []byte      `db:"theme_settings" json:"theme_settings"`
}

func (q *Queries) CreateRestaurant(ctx context.Context, arg CreateRestaurantParams) (Restaurant, error) {
	row := q.db.QueryRow(ctx, createRestaurant,
		arg.OwnerID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.CuisineType,
		arg.Phone,
		arg.Email,
		arg.Website,
		arg.Address,
		arg.City,
		arg.Country,
		arg.LogoUrl,
		arg.CoverImageUrl,
		arg.ThemeSettings,
	)
	var i Restaurant
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.CuisineType,
		&i.Phone,
		&i.Email,
		&i.Website,
		&i.Address,
		&i.City,
		&i.Country,
		&i.LogoUrl,
		&i.CoverImageUrl,
		&i.ThemeSettings,
		&i.IsPublished,
		&i.ViewCount,
		&i.RankScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO subscriptions (
    owner_id, plan_id, status, current_period_start, current_period_end, trial_end
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, owner_id, plan_id, status, current_period_start, current_period_end, trial_end, cancelled_at, payment_provider_subscription_id, created_at, updated_at
`

type CreateSubscriptionParams struct {
	OwnerID            uuid.UUID          `db:"owner_id" json:"owner_id"`
	PlanID             uuid.UUID          `db:"plan_id" json:"plan_id"`
	Status             SubscriptionStatus `db:"status" json:"status"`
	CurrentPeriodStart pgtype.Timestamp   `db:"current_period_start" json:"current_period_start"`
	CurrentPeriodEnd   pgtype.Timestamp   `db:"current_period_end" json:"current_period_end"`
	TrialEnd           pgtype.Timestamp   `db:"trial_end" json:"trial_end"`
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, createSubscription,
		arg.OwnerID,
		arg.PlanID,
		arg.Status,
		arg.CurrentPeriodStart,
		arg.CurrentPeriodEnd,
		arg.TrialEnd,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.PlanID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.TrialEnd,
		&i.CancelledAt,
		&i.PaymentProviderSubscriptionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSubscriptionPlan = `-- name: CreateSubscriptionPlan :one
INSERT INTO subscription_plans (
    name, slug, description, price_monthly, price_annual, currency, features, display_order
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, name, slug, description, price_monthly, price_annual, currency, features, display_order, is_active, created_at, updated_at
`

type CreateSubscriptionPlanParams struct {
	Name         string      `db:"name" json:"name"`
	Slug         string      `db:"slug" json:"slug"`
	Description  pgtype.Text `db:"description" json:"description"`
	PriceMonthly int32       `db:"price_monthly" json:"price_monthly"`
	PriceAnnual  pgtype.Int4 `db:"price_annual" json:"price_annual"`
	Currency     string      `db:"currency" json:"currency"`
	Features     []byte      `db:"features" json:"features"`
	DisplayOrder int32       `db:"display_order" json:"display_order"`
}

func (q *Queries) CreateSubscriptionPlan(ctx context.Context, arg CreateSubscriptionPlanParams) (SubscriptionPlan, error) {
	row := q.db.QueryRow(ctx, createSubscriptionPlan,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.PriceMonthly,
		arg.PriceAnnual,
		arg.Currency,
		arg.Features,
		arg.DisplayOrder,
	)
	var i SubscriptionPlan
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.PriceMonthly,
		&i.PriceAnnual,
		&i.Currency,
		&i.Features,
		&i.DisplayOrder,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    email, password_hash, full_name, role, owner_id, restaurant_id, phone, avatar_url
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, email, password_hash, full_name, role, owner_id, restaurant_id, phone, avatar_url, email_verified, last_login_at, is_active, created_at, updated_at,  email_verified_at, verification_token, verification_token_expires_at, trial_ends_at
`

type CreateUserParams struct {
	Email        string      `db:"email" json:"email"`
	PasswordHash string      `db:"password_hash" json:"password_hash"`
	FullName     string      `db:"full_name" json:"full_name"`
	Role         UserRole    `db:"role" json:"role"`
	OwnerID      *uuid.UUID  `db:"owner_id" json:"owner_id"`
	RestaurantID *uuid.UUID  `db:"restaurant_id" json:"restaurant_id"`
	Phone        pgtype.Text `db:"phone" json:"phone"`
	AvatarUrl    pgtype.Text `db:"avatar_url" json:"avatar_url"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.PasswordHash,
		arg.FullName,
		arg.Role,
		arg.OwnerID,
		arg.RestaurantID,
		arg.Phone,
		arg.AvatarUrl,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.Role,
		&i.OwnerID,
		&i.RestaurantID,
		&i.Phone,
		&i.AvatarUrl,
		&i.EmailVerified,
		&i.LastLoginAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EmailVerifiedAt,
		&i.VerificationToken,
		&i.VerificationTokenExpiresAt,
		&i.TrialEndsAt,
	)
	return i, err
}

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM categories WHERE id = $1
`

func (q *Queries) DeleteCategory(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCategory, id)
	return err
}

const deleteMenuItem = `-- name: DeleteMenuItem :exec
DELETE FROM menu_items WHERE id = $1
`

func (q *Queries) DeleteMenuItem(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteMenuItem, id)
	return err
}

const deleteRestaurant = `-- name: DeleteRestaurant :exec
DELETE FROM restaurants WHERE id = $1 AND owner_id = $2
`

type DeleteRestaurantParams struct {
	ID      uuid.UUID `db:"id" json:"id"`
	OwnerID uuid.UUID `db:"owner_id" json:"owner_id"`
}

func (q *Queries) DeleteRestaurant(ctx context.Context, arg DeleteRestaurantParams) error {
	_, err := q.db.Exec(ctx, deleteRestaurant, arg.ID, arg.OwnerID)
	return err
}

const deleteStaff = `-- name: DeleteStaff :exec
DELETE FROM users
WHERE id = $1 AND restaurant_id = $2 AND role = 'staff'
`

type DeleteStaffParams struct {
	ID           uuid.UUID  `db:"id" json:"id"`
	RestaurantID *uuid.UUID `db:"restaurant_id" json:"restaurant_id"`
}

func (q *Queries) DeleteStaff(ctx context.Context, arg DeleteStaffParams) error {
	_, err := q.db.Exec(ctx, deleteStaff, arg.ID, arg.RestaurantID)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getAdminDashboardStats = `-- name: GetAdminDashboardStats :one
SELECT 
    (SELECT COUNT(*) FROM users) as total_users,
    (SELECT COUNT(*) FROM restaurants) as total_restaurants,
    (SELECT COUNT(*) FROM subscriptions WHERE status = 'active') as active_subscriptions,
    (SELECT SUM(amount) FROM invoices WHERE status = 'paid') as total_revenue
`

type GetAdminDashboardStatsRow struct {
	TotalUsers          int64 `db:"total_users" json:"total_users"`
	TotalRestaurants    int64 `db:"total_restaurants" json:"total_restaurants"`
	ActiveSubscriptions int64 `db:"active_subscriptions" json:"active_subscriptions"`
	TotalRevenue        int64 `db:"total_revenue" json:"total_revenue"`
}

func (q *Queries) GetAdminDashboardStats(ctx context.Context) (GetAdminDashboardStatsRow, error) {
	row := q.db.QueryRow(ctx, getAdminDashboardStats)
	var i GetAdminDashboardStatsRow
	err := row.Scan(
		&i.TotalUsers,
		&i.TotalRestaurants,
		&i.ActiveSubscriptions,
		&i.TotalRevenue,
	)
	return i, err
}

const getAllAdminEmails = `-- name: GetAllAdminEmails :many
SELECT email FROM users
WHERE role = 'admin' 
`

func (q *Queries) GetAllAdminEmails(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getAllAdminEmails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var email string
		if err := rows.Scan(&email); err != nil {
			return nil, err
		}
		items = append(items, email)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnalyticsAggregates = `-- name: GetAnalyticsAggregates :many
SELECT id, restaurant_id, date, hour, metric_type, target_id, value, created_at, updated_at FROM analytics_aggregates
WHERE restaurant_id = $1 AND date >= $2 AND date <= $3
ORDER BY date ASC, hour ASC
`

type GetAnalyticsAggregatesParams struct {
	RestaurantID uuid.UUID   `db:"restaurant_id" json:"restaurant_id"`
	Date         pgtype.Date `db:"date" json:"date"`
	Date_2       pgtype.Date `db:"date_2" json:"date_2"`
}

func (q *Queries) GetAnalyticsAggregates(ctx context.Context, arg GetAnalyticsAggregatesParams) ([]AnalyticsAggregate, error) {
	rows, err := q.db.Query(ctx, getAnalyticsAggregates, arg.RestaurantID, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AnalyticsAggregate
	for rows.Next() {
		var i AnalyticsAggregate
		if err := rows.Scan(
			&i.ID,
			&i.RestaurantID,
			&i.Date,
			&i.Hour,
			&i.MetricType,
			&i.TargetID,
			&i.Value,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryByID = `-- name: GetCategoryByID :one
SELECT id, restaurant_id, name, description, icon, display_order, is_active, created_by, created_at, updated_at FROM categories
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCategoryByID(ctx context.Context, id uuid.UUID) (Category, error) {
	row := q.db.QueryRow(ctx, getCategoryByID, id)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.RestaurantID,
		&i.Name,
		&i.Description,
		&i.Icon,
		&i.DisplayOrder,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMenuItemByID = `-- name: GetMenuItemByID :one
SELECT id, restaurant_id, category_id, name, description, price, currency, images, allergens, dietary_tags, spice_level, calories, is_available, display_order, view_count, created_by, created_at, updated_at FROM menu_items
WHERE id = $1  LIMIT 1
`

func (q *Queries) GetMenuItemByID(ctx context.Context, id uuid.UUID) (MenuItem, error) {
	row := q.db.QueryRow(ctx, getMenuItemByID, id)
	var i MenuItem
	err := row.Scan(
		&i.ID,
		&i.RestaurantID,
		&i.CategoryID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.Currency,
		&i.Images,
		&i.Allergens,
		&i.DietaryTags,
		&i.SpiceLevel,
		&i.Calories,
		&i.IsAvailable,
		&i.DisplayOrder,
		&i.ViewCount,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentTransactionByTxRef = `-- name: GetPaymentTransactionByTxRef :one
SELECT id, owner_id, amount, currency, status, tx_ref, reference, provider_transaction_ref, created_at, updated_at FROM payment_transactions
WHERE tx_ref = $1 LIMIT 1
`

func (q *Queries) GetPaymentTransactionByTxRef(ctx context.Context, txRef string) (PaymentTransaction, error) {
	row := q.db.QueryRow(ctx, getPaymentTransactionByTxRef, txRef)
	var i PaymentTransaction
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.TxRef,
		&i.Reference,
		&i.ProviderTransactionRef,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRecentAdminLogs = `-- name: GetRecentAdminLogs :many
SELECT al.id, al.restaurant_id, al.user_id, al.action_type, al.action_category, al.description, al.target_type, al.target_id, al.target_name, al.before_value, al.after_value, al.ip_address, al.user_agent, al.device_type, al.browser, al.os, al.success, al.created_at, u.full_name as user_name, u.email as user_email
FROM activity_logs al
JOIN users u ON al.user_id = u.id
ORDER BY al.created_at DESC
LIMIT $1
`

type GetRecentAdminLogsRow struct {
	ID             uuid.UUID        `db:"id" json:"id"`
	RestaurantID   uuid.UUID        `db:"restaurant_id" json:"restaurant_id"`
	UserID         uuid.UUID        `db:"user_id" json:"user_id"`
	ActionType     string           `db:"action_type" json:"action_type"`
	ActionCategory string           `db:"action_category" json:"action_category"`
	Description    pgtype.Text      `db:"description" json:"description"`
	TargetType     pgtype.Text      `db:"target_type" json:"target_type"`
	TargetID       *uuid.UUID       `db:"target_id" json:"target_id"`
	TargetName     pgtype.Text      `db:"target_name" json:"target_name"`
	BeforeValue    []byte           `db:"before_value" json:"before_value"`
	AfterValue     []byte           `db:"after_value" json:"after_value"`
	IpAddress      pgtype.Text      `db:"ip_address" json:"ip_address"`
	UserAgent      pgtype.Text      `db:"user_agent" json:"user_agent"`
	DeviceType     pgtype.Text      `db:"device_type" json:"device_type"`
	Browser        pgtype.Text      `db:"browser" json:"browser"`
	Os             pgtype.Text      `db:"os" json:"os"`
	Success        pgtype.Bool      `db:"success" json:"success"`
	CreatedAt      pgtype.Timestamp `db:"created_at" json:"created_at"`
	UserName       string           `db:"user_name" json:"user_name"`
	UserEmail      string           `db:"user_email" json:"user_email"`
}

func (q *Queries) GetRecentAdminLogs(ctx context.Context, limit int32) ([]GetRecentAdminLogsRow, error) {
	rows, err := q.db.Query(ctx, getRecentAdminLogs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentAdminLogsRow
	for rows.Next() {
		var i GetRecentAdminLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.RestaurantID,
			&i.UserID,
			&i.ActionType,
			&i.ActionCategory,
			&i.Description,
			&i.TargetType,
			&i.TargetID,
			&i.TargetName,
			&i.BeforeValue,
			&i.AfterValue,
			&i.IpAddress,
			&i.UserAgent,
			&i.DeviceType,
			&i.Browser,
			&i.Os,
			&i.Success,
			&i.CreatedAt,
			&i.UserName,
			&i.UserEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRestaurantByID = `-- name: GetRestaurantByID :one
SELECT id, owner_id, name, slug, description, cuisine_type, phone, email, website, address, city, country, logo_url, cover_image_url, theme_settings, is_published, status, view_count, rank_score, created_at, updated_at FROM restaurants
WHERE id = $1  LIMIT 1
`

func (q *Queries) GetRestaurantByID(ctx context.Context, id uuid.UUID) (Restaurant, error) {
	row := q.db.QueryRow(ctx, getRestaurantByID, id)
	var i Restaurant
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.CuisineType,
		&i.Phone,
		&i.Email,
		&i.Website,
		&i.Address,
		&i.City,
		&i.Country,
		&i.LogoUrl,
		&i.CoverImageUrl,
		&i.ThemeSettings,
		&i.IsPublished,
		&i.ViewCount,
		&i.RankScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRestaurantBySlug = `-- name: GetRestaurantBySlug :one
SELECT id, owner_id, name, slug, description, cuisine_type, phone, email, website, address, city, country, logo_url, cover_image_url, theme_settings, is_published, status, view_count, rank_score, created_at, updated_at FROM restaurants
WHERE slug = $1  LIMIT 1
`

func (q *Queries) GetRestaurantBySlug(ctx context.Context, slug string) (Restaurant, error) {
	row := q.db.QueryRow(ctx, getRestaurantBySlug, slug)
	var i Restaurant
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.CuisineType,
		&i.Phone,
		&i.Email,
		&i.Website,
		&i.Address,
		&i.City,
		&i.Country,
		&i.LogoUrl,
		&i.CoverImageUrl,
		&i.ThemeSettings,
		&i.IsPublished,
		&i.ViewCount,
		&i.RankScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRestaurantDetailsForAdmin = `-- name: GetRestaurantDetailsForAdmin :one
SELECT r.id, r.owner_id, r.name, r.slug, r.description, r.cuisine_type, r.phone, r.email, r.website, r.address, r.city, r.country, r.logo_url, r.cover_image_url, r.theme_settings, r.is_published, r.status, r.view_count, r.rank_score, r.created_at, r.updated_at, r. u.full_name as owner_name, u.email as owner_email
FROM restaurants r
JOIN users u ON r.owner_id = u.id
WHERE r.id = $1
`

type GetRestaurantDetailsForAdminRow struct {
	ID            uuid.UUID        `db:"id" json:"id"`
	OwnerID       uuid.UUID        `db:"owner_id" json:"owner_id"`
	Name          string           `db:"name" json:"name"`
	Slug          string           `db:"slug" json:"slug"`
	Description   pgtype.Text      `db:"description" json:"description"`
	CuisineType   pgtype.Text      `db:"cuisine_type" json:"cuisine_type"`
	Phone         pgtype.Text      `db:"phone" json:"phone"`
	Email         pgtype.Text      `db:"email" json:"email"`
	Website       pgtype.Text      `db:"website" json:"website"`
	Address       pgtype.Text      `db:"address" json:"address"`
	City          pgtype.Text      `db:"city" json:"city"`
	Country       pgtype.Text      `db:"country" json:"country"`
	LogoUrl       pgtype.Text      `db:"logo_url" json:"logo_url"`
	CoverImageUrl pgtype.Text      `db:"cover_image_url" json:"cover_image_url"`
	ThemeSettings []byte           `db:"theme_settings" json:"theme_settings"`
	IsPublished   bool             `db:"is_published" json:"is_published"`
	Status        RestaurantStatus `db:"status" json:"status"`
	ViewCount     pgtype.Int4      `db:"view_count" json:"view_count"`
	RankScore     pgtype.Numeric   `db:"rank_score" json:"rank_score"`
	CreatedAt     pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt     pgtype.Timestamp `db:"updated_at" json:"updated_at"`

	OwnerName  string `db:"owner_name" json:"owner_name"`
	OwnerEmail string `db:"owner_email" json:"owner_email"`
}

func (q *Queries) GetRestaurantDetailsForAdmin(ctx context.Context, id uuid.UUID) (GetRestaurantDetailsForAdminRow, error) {
	row := q.db.QueryRow(ctx, getRestaurantDetailsForAdmin, id)
	var i GetRestaurantDetailsForAdminRow
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.CuisineType,
		&i.Phone,
		&i.Email,
		&i.Website,
		&i.Address,
		&i.City,
		&i.Country,
		&i.LogoUrl,
		&i.CoverImageUrl,
		&i.ThemeSettings,
		&i.IsPublished,
		&i.Status,
		&i.ViewCount,
		&i.RankScore,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OwnerName,
		&i.OwnerEmail,
	)
	return i, err
}

const getSubscriptionByOwner = `-- name: GetSubscriptionByOwner :one
SELECT s.id, s.owner_id, s.plan_id, s.status, s.current_period_start, s.current_period_end, s.trial_end, s.cancelled_at, s.payment_provider_subscription_id, s.created_at, s.updated_at, sp.name as plan_name, sp.slug as plan_slug, sp.features
FROM subscriptions s
JOIN subscription_plans sp ON s.plan_id = sp.id
WHERE s.owner_id = $1 LIMIT 1
`

type GetSubscriptionByOwnerRow struct {
	ID                            uuid.UUID          `db:"id" json:"id"`
	OwnerID                       uuid.UUID          `db:"owner_id" json:"owner_id"`
	PlanID                        uuid.UUID          `db:"plan_id" json:"plan_id"`
	Status                        SubscriptionStatus `db:"status" json:"status"`
	CurrentPeriodStart            pgtype.Timestamp   `db:"current_period_start" json:"current_period_start"`
	CurrentPeriodEnd              pgtype.Timestamp   `db:"current_period_end" json:"current_period_end"`
	TrialEnd                      pgtype.Timestamp   `db:"trial_end" json:"trial_end"`
	CancelledAt                   pgtype.Timestamp   `db:"cancelled_at" json:"cancelled_at"`
	PaymentProviderSubscriptionID pgtype.Text        `db:"payment_provider_subscription_id" json:"payment_provider_subscription_id"`
	CreatedAt                     pgtype.Timestamp   `db:"created_at" json:"created_at"`
	UpdatedAt                     pgtype.Timestamp   `db:"updated_at" json:"updated_at"`
	PlanName                      string             `db:"plan_name" json:"plan_name"`
	PlanSlug                      string             `db:"plan_slug" json:"plan_slug"`
	Features                      []byte             `db:"features" json:"features"`
}

func (q *Queries) GetSubscriptionByOwner(ctx context.Context, ownerID uuid.UUID) (GetSubscriptionByOwnerRow, error) {
	row := q.db.QueryRow(ctx, getSubscriptionByOwner, ownerID)
	var i GetSubscriptionByOwnerRow
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.PlanID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.TrialEnd,
		&i.CancelledAt,
		&i.PaymentProviderSubscriptionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PlanName,
		&i.PlanSlug,
		&i.Features,
	)
	return i, err
}

const getSubscriptionPlanBySlug = `-- name: GetSubscriptionPlanBySlug :one
SELECT id, name, slug, description, price_monthly, price_annual, currency, features, display_order, is_active, created_at, updated_at FROM subscription_plans
WHERE slug = $1 LIMIT 1
`

func (q *Queries) GetSubscriptionPlanBySlug(ctx context.Context, slug string) (SubscriptionPlan, error) {
	row := q.db.QueryRow(ctx, getSubscriptionPlanBySlug, slug)
	var i SubscriptionPlan
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.PriceMonthly,
		&i.PriceAnnual,
		&i.Currency,
		&i.Features,
		&i.DisplayOrder,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, full_name, role, owner_id, restaurant_id, phone, avatar_url, email_verified, last_login_at, is_active, created_at, updated_at, email_verified_at, verification_token, verification_token_expires_at, trial_ends_at FROM users
WHERE email = $1  LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.Role,
		&i.OwnerID,
		&i.RestaurantID,
		&i.Phone,
		&i.AvatarUrl,
		&i.EmailVerified,
		&i.LastLoginAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EmailVerifiedAt,
		&i.VerificationToken,
		&i.VerificationTokenExpiresAt,
		&i.TrialEndsAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, password_hash, full_name, role, owner_id, restaurant_id, phone, avatar_url, email_verified, last_login_at, is_active, created_at, updated_at,  email_verified_at, verification_token, verification_token_expires_at, trial_ends_at FROM users
WHERE id = $1  LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.Role,
		&i.OwnerID,
		&i.RestaurantID,
		&i.Phone,
		&i.AvatarUrl,
		&i.EmailVerified,
		&i.LastLoginAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EmailVerifiedAt,
		&i.VerificationToken,
		&i.VerificationTokenExpiresAt,
		&i.TrialEndsAt,
	)
	return i, err
}

const incrementMenuItemViewCount = `-- name: IncrementMenuItemViewCount :exec
UPDATE menu_items SET view_count = view_count + 1 WHERE id = $1
`

func (q *Queries) IncrementMenuItemViewCount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, incrementMenuItemViewCount, id)
	return err
}

const incrementRestaurantViewCount = `-- name: IncrementRestaurantViewCount :exec
UPDATE restaurants SET view_count = view_count + 1 WHERE id = $1
`

func (q *Queries) IncrementRestaurantViewCount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, incrementRestaurantViewCount, id)
	return err
}

const listActivityLogsByRestaurant = `-- name: ListActivityLogsByRestaurant :many
SELECT al.id, al.restaurant_id, al.user_id, al.action_type, al.action_category, al.description, al.target_type, al.target_id, al.target_name, al.before_value, al.after_value, al.ip_address, al.user_agent, al.device_type, al.browser, al.os, al.success, al.created_at, u.full_name as user_name, u.email as user_email
FROM activity_logs al
JOIN users u ON al.user_id = u.id
WHERE al.restaurant_id = $1
ORDER BY al.created_at DESC
LIMIT $2 OFFSET $3
`

type ListActivityLogsByRestaurantParams struct {
	RestaurantID uuid.UUID `db:"restaurant_id" json:"restaurant_id"`
	Limit        int32     `db:"limit" json:"limit"`
	Offset       int32     `db:"offset" json:"offset"`
}

type ListActivityLogsByRestaurantRow struct {
	ID             uuid.UUID        `db:"id" json:"id"`
	RestaurantID   uuid.UUID        `db:"restaurant_id" json:"restaurant_id"`
	UserID         uuid.UUID        `db:"user_id" json:"user_id"`
	ActionType     string           `db:"action_type" json:"action_type"`
	ActionCategory string           `db:"action_category" json:"action_category"`
	Description    pgtype.Text      `db:"description" json:"description"`
	TargetType     pgtype.Text      `db:"target_type" json:"target_type"`
	TargetID       *uuid.UUID       `db:"target_id" json:"target_id"`
	TargetName     pgtype.Text      `db:"target_name" json:"target_name"`
	BeforeValue    []byte           `db:"before_value" json:"before_value"`
	AfterValue     []byte           `db:"after_value" json:"after_value"`
	IpAddress      pgtype.Text      `db:"ip_address" json:"ip_address"`
	UserAgent      pgtype.Text      `db:"user_agent" json:"user_agent"`
	DeviceType     pgtype.Text      `db:"device_type" json:"device_type"`
	Browser        pgtype.Text      `db:"browser" json:"browser"`
	Os             pgtype.Text      `db:"os" json:"os"`
	Success        pgtype.Bool      `db:"success" json:"success"`
	CreatedAt      pgtype.Timestamp `db:"created_at" json:"created_at"`
	UserName       string           `db:"user_name" json:"user_name"`
	UserEmail      string           `db:"user_email" json:"user_email"`
}

func (q *Queries) ListActivityLogsByRestaurant(ctx context.Context, arg ListActivityLogsByRestaurantParams) ([]ListActivityLogsByRestaurantRow, error) {
	rows, err := q.db.Query(ctx, listActivityLogsByRestaurant, arg.RestaurantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActivityLogsByRestaurantRow
	for rows.Next() {
		var i ListActivityLogsByRestaurantRow
		if err := rows.Scan(
			&i.ID,
			&i.RestaurantID,
			&i.UserID,
			&i.ActionType,
			&i.ActionCategory,
			&i.Description,
			&i.TargetType,
			&i.TargetID,
			&i.TargetName,
			&i.BeforeValue,
			&i.AfterValue,
			&i.IpAddress,
			&i.UserAgent,
			&i.DeviceType,
			&i.Browser,
			&i.Os,
			&i.Success,
			&i.CreatedAt,
			&i.UserName,
			&i.UserEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActivityLogsWithFilters = `-- name: ListActivityLogsWithFilters :many
SELECT al.id, al.restaurant_id, al.user_id, al.action_type, al.action_category, al.description, al.target_type, al.target_id, al.target_name, al.before_value, al.after_value, al.ip_address, al.user_agent, al.device_type, al.browser, al.os, al.success, al.created_at, u.full_name as user_name, u.email as user_email
FROM activity_logs al
JOIN users u ON al.user_id = u.id
WHERE 
    ($3::uuid IS NULL OR al.restaurant_id = $3) AND
    ($4::uuid IS NULL OR al.user_id = $4) AND
    ($5::text IS NULL OR al.action_type = $5) AND
    ($6::text IS NULL OR al.action_category = $6) AND
    ($7::text IS NULL OR al.target_type = $7) AND
    ($8::uuid IS NULL OR al.target_id = $8) AND
    ($9::boolean IS NULL OR al.success = $9) AND
    ($10::text IS NULL OR al.description ILIKE '%' || $10 || '%' OR al.target_name ILIKE '%' || $10 || '%')
ORDER BY al.created_at DESC
LIMIT $1 OFFSET $2
`

type ListActivityLogsWithFiltersParams struct {
	Limit          int32       `db:"limit" json:"limit"`
	Offset         int32       `db:"offset" json:"offset"`
	RestaurantID   *uuid.UUID  `db:"restaurant_id" json:"restaurant_id"`
	UserID         *uuid.UUID  `db:"user_id" json:"user_id"`
	ActionType     pgtype.Text `db:"action_type" json:"action_type"`
	ActionCategory pgtype.Text `db:"action_category" json:"action_category"`
	TargetType     pgtype.Text `db:"target_type" json:"target_type"`
	TargetID       *uuid.UUID  `db:"target_id" json:"target_id"`
	Success        pgtype.Bool `db:"success" json:"success"`
	Search         pgtype.Text `db:"search" json:"search"`
}

type ListActivityLogsWithFiltersRow struct {
	ID             uuid.UUID        `db:"id" json:"id"`
	RestaurantID   uuid.UUID        `db:"restaurant_id" json:"restaurant_id"`
	UserID         uuid.UUID        `db:"user_id" json:"user_id"`
	ActionType     string           `db:"action_type" json:"action_type"`
	ActionCategory string           `db:"action_category" json:"action_category"`
	Description    pgtype.Text      `db:"description" json:"description"`
	TargetType     pgtype.Text      `db:"target_type" json:"target_type"`
	TargetID       *uuid.UUID       `db:"target_id" json:"target_id"`
	TargetName     pgtype.Text      `db:"target_name" json:"target_name"`
	BeforeValue    []byte           `db:"before_value" json:"before_value"`
	AfterValue     []byte           `db:"after_value" json:"after_value"`
	IpAddress      pgtype.Text      `db:"ip_address" json:"ip_address"`
	UserAgent      pgtype.Text      `db:"user_agent" json:"user_agent"`
	DeviceType     pgtype.Text      `db:"device_type" json:"device_type"`
	Browser        pgtype.Text      `db:"browser" json:"browser"`
	Os             pgtype.Text      `db:"os" json:"os"`
	Success        pgtype.Bool      `db:"success" json:"success"`
	CreatedAt      pgtype.Timestamp `db:"created_at" json:"created_at"`
	UserName       string           `db:"user_name" json:"user_name"`
	UserEmail      string           `db:"user_email" json:"user_email"`
}

func (q *Queries) ListActivityLogsWithFilters(ctx context.Context, arg ListActivityLogsWithFiltersParams) ([]ListActivityLogsWithFiltersRow, error) {
	rows, err := q.db.Query(ctx, listActivityLogsWithFilters,
		arg.Limit,
		arg.Offset,
		arg.RestaurantID,
		arg.UserID,
		arg.ActionType,
		arg.ActionCategory,
		arg.TargetType,
		arg.TargetID,
		arg.Success,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActivityLogsWithFiltersRow
	for rows.Next() {
		var i ListActivityLogsWithFiltersRow
		if err := rows.Scan(
			&i.ID,
			&i.RestaurantID,
			&i.UserID,
			&i.ActionType,
			&i.ActionCategory,
			&i.Description,
			&i.TargetType,
			&i.TargetID,
			&i.TargetName,
			&i.BeforeValue,
			&i.AfterValue,
			&i.IpAddress,
			&i.UserAgent,
			&i.DeviceType,
			&i.Browser,
			&i.Os,
			&i.Success,
			&i.CreatedAt,
			&i.UserName,
			&i.UserEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAnalyticsEventsWithFilters = `-- name: ListAnalyticsEventsWithFilters :many
SELECT id, restaurant_id, event_type, visitor_id, session_id, target_id, ip_address, device_type, browser, os, country, city, created_at FROM analytics_events
WHERE 
    ($3::uuid IS NULL OR restaurant_id = $3) AND
    ($4::text IS NULL OR event_type = $4) AND
    ($5::text IS NULL OR visitor_id = $5) AND
    ($6::uuid IS NULL OR session_id = $6) AND
    ($7::uuid IS NULL OR target_id = $7) AND
    ($8::text IS NULL OR country = $8) AND
    ($9::text IS NULL OR city = $9)
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListAnalyticsEventsWithFiltersParams struct {
	Limit        int32       `db:"limit" json:"limit"`
	Offset       int32       `db:"offset" json:"offset"`
	RestaurantID *uuid.UUID  `db:"restaurant_id" json:"restaurant_id"`
	EventType    pgtype.Text `db:"event_type" json:"event_type"`
	VisitorID    pgtype.Text `db:"visitor_id" json:"visitor_id"`
	SessionID    *uuid.UUID  `db:"session_id" json:"session_id"`
	TargetID     *uuid.UUID  `db:"target_id" json:"target_id"`
	Country      pgtype.Text `db:"country" json:"country"`
	City         pgtype.Text `db:"city" json:"city"`
}

func (q *Queries) ListAnalyticsEventsWithFilters(ctx context.Context, arg ListAnalyticsEventsWithFiltersParams) ([]AnalyticsEvent, error) {
	rows, err := q.db.Query(ctx, listAnalyticsEventsWithFilters,
		arg.Limit,
		arg.Offset,
		arg.RestaurantID,
		arg.EventType,
		arg.VisitorID,
		arg.SessionID,
		arg.TargetID,
		arg.Country,
		arg.City,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AnalyticsEvent
	for rows.Next() {
		var i AnalyticsEvent
		if err := rows.Scan(
			&i.ID,
			&i.RestaurantID,
			&i.EventType,
			&i.VisitorID,
			&i.SessionID,
			&i.TargetID,
			&i.IpAddress,
			&i.DeviceType,
			&i.Browser,
			&i.Os,
			&i.Country,
			&i.City,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCategoriesByRestaurant = `-- name: ListCategoriesByRestaurant :many
SELECT id, restaurant_id, name, description, icon, display_order, is_active, created_by, created_at, updated_at FROM categories
WHERE restaurant_id = $1
ORDER BY display_order ASC
`

func (q *Queries) ListCategoriesByRestaurant(ctx context.Context, restaurantID uuid.UUID) ([]Category, error) {
	rows, err := q.db.Query(ctx, listCategoriesByRestaurant, restaurantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.RestaurantID,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.DisplayOrder,
			&i.IsActive,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoicesByOwner = `-- name: ListInvoicesByOwner :many
SELECT id, subscription_id, owner_id, invoice_number, amount, currency, status, billing_period_start, billing_period_end, payment_provider_invoice_id, paid_at, created_at, updated_at FROM invoices
WHERE owner_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListInvoicesByOwner(ctx context.Context, ownerID uuid.UUID) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, listInvoicesByOwner, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.OwnerID,
			&i.InvoiceNumber,
			&i.Amount,
			&i.Currency,
			&i.Status,
			&i.BillingPeriodStart,
			&i.BillingPeriodEnd,
			&i.PaymentProviderInvoiceID,
			&i.PaidAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoicesWithFilters = `-- name: ListInvoicesWithFilters :many
SELECT id, subscription_id, owner_id, invoice_number, amount, currency, status, billing_period_start, billing_period_end, payment_provider_invoice_id, paid_at, created_at, updated_at FROM invoices
WHERE 
    ($3::uuid IS NULL OR owner_id = $3) AND
    ($4::uuid IS NULL OR subscription_id = $4) AND
    ($5::invoice_status IS NULL OR status = $5)
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListInvoicesWithFiltersParams struct {
	Limit          int32             `db:"limit" json:"limit"`
	Offset         int32             `db:"offset" json:"offset"`
	OwnerID        *uuid.UUID        `db:"owner_id" json:"owner_id"`
	SubscriptionID *uuid.UUID        `db:"subscription_id" json:"subscription_id"`
	Status         NullInvoiceStatus `db:"status" json:"status"`
}

func (q *Queries) ListInvoicesWithFilters(ctx context.Context, arg ListInvoicesWithFiltersParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, listInvoicesWithFilters,
		arg.Limit,
		arg.Offset,
		arg.OwnerID,
		arg.SubscriptionID,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.OwnerID,
			&i.InvoiceNumber,
			&i.Amount,
			&i.Currency,
			&i.Status,
			&i.BillingPeriodStart,
			&i.BillingPeriodEnd,
			&i.PaymentProviderInvoiceID,
			&i.PaidAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMenuItemsByCategory = `-- name: ListMenuItemsByCategory :many
SELECT id, restaurant_id, category_id, name, description, price, currency, images, allergens, dietary_tags, spice_level, calories, is_available, display_order, view_count, created_by, created_at, updated_at FROM menu_items
WHERE category_id = $1 
ORDER BY display_order ASC
`

func (q *Queries) ListMenuItemsByCategory(ctx context.Context, categoryID uuid.UUID) ([]MenuItem, error) {
	rows, err := q.db.Query(ctx, listMenuItemsByCategory, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MenuItem
	for rows.Next() {
		var i MenuItem
		if err := rows.Scan(
			&i.ID,
			&i.RestaurantID,
			&i.CategoryID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.Currency,
			&i.Images,
			&i.Allergens,
			&i.DietaryTags,
			&i.SpiceLevel,
			&i.Calories,
			&i.IsAvailable,
			&i.DisplayOrder,
			&i.ViewCount,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMenuItemsByRestaurant = `-- name: ListMenuItemsByRestaurant :many
SELECT id, restaurant_id, category_id, name, description, price, currency, images, allergens, dietary_tags, spice_level, calories, is_available, display_order, view_count, created_by, created_at, updated_at FROM menu_items
WHERE restaurant_id = $1 
ORDER BY category_id, display_order ASC
`

func (q *Queries) ListMenuItemsByRestaurant(ctx context.Context, restaurantID uuid.UUID) ([]MenuItem, error) {
	rows, err := q.db.Query(ctx, listMenuItemsByRestaurant, restaurantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MenuItem
	for rows.Next() {
		var i MenuItem
		if err := rows.Scan(
			&i.ID,
			&i.RestaurantID,
			&i.CategoryID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.Currency,
			&i.Images,
			&i.Allergens,
			&i.DietaryTags,
			&i.SpiceLevel,
			&i.Calories,
			&i.IsAvailable,
			&i.DisplayOrder,
			&i.ViewCount,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRestaurantsByOwner = `-- name: ListRestaurantsByOwner :many
SELECT id, owner_id, name, slug, description, cuisine_type, phone, email, website, address, city, country, logo_url, cover_image_url, theme_settings, is_published, view_count, rank_score, created_at, updated_at FROM restaurants
WHERE owner_id = $1 
ORDER BY created_at DESC
`

func (q *Queries) ListRestaurantsByOwner(ctx context.Context, ownerID uuid.UUID) ([]Restaurant, error) {
	rows, err := q.db.Query(ctx, listRestaurantsByOwner, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Restaurant
	for rows.Next() {
		var i Restaurant
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.CuisineType,
			&i.Phone,
			&i.Email,
			&i.Website,
			&i.Address,
			&i.City,
			&i.Country,
			&i.LogoUrl,
			&i.CoverImageUrl,
			&i.ThemeSettings,
			&i.IsPublished,
			&i.ViewCount,
			&i.RankScore,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRestaurantsWithFilters = `-- name: ListRestaurantsWithFilters :many
SELECT id, owner_id, name, slug, description, cuisine_type, phone, email, website, address, city, country, logo_url, cover_image_url, theme_settings, is_published, view_count, rank_score, created_at, updated_at FROM restaurants
WHERE 
    ($3::uuid IS NULL OR owner_id = $3) AND
    ($4::boolean IS NULL OR is_published = $4) AND
    ($5::text IS NULL OR cuisine_type = $5) AND
    ($6::text IS NULL OR city = $6) AND
    ($7::text IS NULL OR country = $7) AND
    ($8::boolean IS NULL OR is_published = $8) AND
    ($9::text IS NULL OR name ILIKE '%' || $9 || '%') 
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListRestaurantsWithFiltersParams struct {
	Limit       int32                `db:"limit" json:"limit"`
	Offset      int32                `db:"offset" json:"offset"`
	OwnerID     *uuid.UUID           `db:"owner_id" json:"owner_id"`
	CuisineType pgtype.Text          `db:"cuisine_type" json:"cuisine_type"`
	City        pgtype.Text          `db:"city" json:"city"`
	Country     pgtype.Text          `db:"country" json:"country"`
	IsPublished pgtype.Bool          `db:"is_published" json:"is_published"`
	Search      pgtype.Text          `db:"search" json:"search"`
}

func (q *Queries) ListRestaurantsWithFilters(ctx context.Context, arg ListRestaurantsWithFiltersParams) ([]Restaurant, error) {
	rows, err := q.db.Query(ctx, listRestaurantsWithFilters,
		arg.Limit,
		arg.Offset,
		arg.OwnerID,
		arg.IsPublished,
		arg.CuisineType,
		arg.City,
		arg.Country,
		arg.IsPublished,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Restaurant
	for rows.Next() {
		var i Restaurant
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.CuisineType,
			&i.Phone,
			&i.Email,
			&i.Website,
			&i.Address,
			&i.City,
			&i.Country,
			&i.LogoUrl,
			&i.CoverImageUrl,
			&i.ThemeSettings,
			&i.IsPublished,
			&i.ViewCount,
			&i.RankScore,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStaffByOwner = `-- name: ListStaffByOwner :many
SELECT id, email, password_hash, full_name, role, owner_id, restaurant_id, phone, avatar_url, email_verified, last_login_at, is_active, created_at, updated_at,  email_verified_at, verification_token, verification_token_expires_at, trial_ends_at FROM users
WHERE owner_id = $1 AND role = 'staff' 
ORDER BY created_at DESC
`

func (q *Queries) ListStaffByOwner(ctx context.Context, ownerID *uuid.UUID) ([]User, error) {
	rows, err := q.db.Query(ctx, listStaffByOwner, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.PasswordHash,
			&i.FullName,
			&i.Role,
			&i.OwnerID,
			&i.RestaurantID,
			&i.Phone,
			&i.AvatarUrl,
			&i.EmailVerified,
			&i.LastLoginAt,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,

			&i.EmailVerifiedAt,
			&i.VerificationToken,
			&i.VerificationTokenExpiresAt,
			&i.TrialEndsAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStaffByRestaurant = `-- name: ListStaffByRestaurant :many
SELECT id, email, password_hash, full_name, role, owner_id, restaurant_id, phone, avatar_url, email_verified, last_login_at, is_active, created_at, updated_at,  email_verified_at, verification_token, verification_token_expires_at, trial_ends_at FROM users
WHERE restaurant_id = $1 AND role = 'staff' 
ORDER BY created_at DESC
`

func (q *Queries) ListStaffByRestaurant(ctx context.Context, restaurantID *uuid.UUID) ([]User, error) {
	rows, err := q.db.Query(ctx, listStaffByRestaurant, restaurantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.PasswordHash,
			&i.FullName,
			&i.Role,
			&i.OwnerID,
			&i.RestaurantID,
			&i.Phone,
			&i.AvatarUrl,
			&i.EmailVerified,
			&i.LastLoginAt,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,

			&i.EmailVerifiedAt,
			&i.VerificationToken,
			&i.VerificationTokenExpiresAt,
			&i.TrialEndsAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionPlans = `-- name: ListSubscriptionPlans :many
SELECT id, name, slug, description, price_monthly, price_annual, currency, features, display_order, is_active, created_at, updated_at FROM subscription_plans
WHERE is_active = TRUE
ORDER BY display_order ASC
`

func (q *Queries) ListSubscriptionPlans(ctx context.Context) ([]SubscriptionPlan, error) {
	rows, err := q.db.Query(ctx, listSubscriptionPlans)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubscriptionPlan
	for rows.Next() {
		var i SubscriptionPlan
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.PriceMonthly,
			&i.PriceAnnual,
			&i.Currency,
			&i.Features,
			&i.DisplayOrder,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, email, password_hash, full_name, role, owner_id, restaurant_id, phone, avatar_url, email_verified, last_login_at, is_active, created_at, updated_at,  email_verified_at, verification_token, verification_token_expires_at, trial_ends_at FROM users
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListUsersParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.PasswordHash,
			&i.FullName,
			&i.Role,
			&i.OwnerID,
			&i.RestaurantID,
			&i.Phone,
			&i.AvatarUrl,
			&i.EmailVerified,
			&i.LastLoginAt,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,

			&i.EmailVerifiedAt,
			&i.VerificationToken,
			&i.VerificationTokenExpiresAt,
			&i.TrialEndsAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersWithFilters = `-- name: ListUsersWithFilters :many
SELECT id, email, password_hash, full_name, role, owner_id, restaurant_id, phone, avatar_url, email_verified, last_login_at, is_active, created_at, updated_at,  email_verified_at, verification_token, verification_token_expires_at, trial_ends_at FROM users
WHERE 
    ($3::text IS NULL OR email = $3) AND
    ($4::user_role IS NULL OR role = $4) AND
    ($5::boolean IS NULL OR is_active = $5) AND
    ($6::text IS NULL OR full_name ILIKE '%' || $6 || '%' OR email ILIKE '%' || $6 || '%') 
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListUsersWithFiltersParams struct {
	Limit    int32        `db:"limit" json:"limit"`
	Offset   int32        `db:"offset" json:"offset"`
	Email    pgtype.Text  `db:"email" json:"email"`
	Role     NullUserRole `db:"role" json:"role"`
	IsActive pgtype.Bool  `db:"is_active" json:"is_active"`
	Search   pgtype.Text  `db:"search" json:"search"`
}

func (q *Queries) ListUsersWithFilters(ctx context.Context, arg ListUsersWithFiltersParams) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsersWithFilters,
		arg.Limit,
		arg.Offset,
		arg.Email,
		arg.Role,
		arg.IsActive,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.PasswordHash,
			&i.FullName,
			&i.Role,
			&i.OwnerID,
			&i.RestaurantID,
			&i.Phone,
			&i.AvatarUrl,
			&i.EmailVerified,
			&i.LastLoginAt,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,

			&i.EmailVerifiedAt,
			&i.VerificationToken,
			&i.VerificationTokenExpiresAt,
			&i.TrialEndsAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markWebhookAsProcessed = `-- name: MarkWebhookAsProcessed :exec
UPDATE payment_webhooks SET processed = TRUE WHERE provider_event_id = $1
`

func (q *Queries) MarkWebhookAsProcessed(ctx context.Context, providerEventID pgtype.Text) error {
	_, err := q.db.Exec(ctx, markWebhookAsProcessed, providerEventID)
	return err
}

const updateCategory = `-- name: UpdateCategory :one
UPDATE categories
SET 
    name = COALESCE($1, name),
    description = COALESCE($2, description),
    icon = COALESCE($3, icon),
    display_order = COALESCE($4, display_order),
    is_active = COALESCE($5, is_active),
    updated_at = NOW()
WHERE id = $6
RETURNING id, restaurant_id, name, description, icon, display_order, is_active, created_by, created_at, updated_at
`

type UpdateCategoryParams struct {
	Name         pgtype.Text `db:"name" json:"name"`
	Description  pgtype.Text `db:"description" json:"description"`
	Icon         pgtype.Text `db:"icon" json:"icon"`
	DisplayOrder pgtype.Int4 `db:"display_order" json:"display_order"`
	IsActive     pgtype.Bool `db:"is_active" json:"is_active"`
	ID           uuid.UUID   `db:"id" json:"id"`
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) (Category, error) {
	row := q.db.QueryRow(ctx, updateCategory,
		arg.Name,
		arg.Description,
		arg.Icon,
		arg.DisplayOrder,
		arg.IsActive,
		arg.ID,
	)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.RestaurantID,
		&i.Name,
		&i.Description,
		&i.Icon,
		&i.DisplayOrder,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateInvoiceStatus = `-- name: UpdateInvoiceStatus :one
UPDATE invoices
SET 
    status = $2,
    paid_at = CASE WHEN $2 = 'paid'::invoice_status THEN NOW() ELSE paid_at END,
    updated_at = NOW()
WHERE invoice_number = $1
RETURNING id, subscription_id, owner_id, invoice_number, amount, currency, status, billing_period_start, billing_period_end, payment_provider_invoice_id, paid_at, created_at, updated_at
`

type UpdateInvoiceStatusParams struct {
	InvoiceNumber string        `db:"invoice_number" json:"invoice_number"`
	Status        InvoiceStatus `db:"status" json:"status"`
}

func (q *Queries) UpdateInvoiceStatus(ctx context.Context, arg UpdateInvoiceStatusParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, updateInvoiceStatus, arg.InvoiceNumber, arg.Status)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.OwnerID,
		&i.InvoiceNumber,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.BillingPeriodStart,
		&i.BillingPeriodEnd,
		&i.PaymentProviderInvoiceID,
		&i.PaidAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMenuItem = `-- name: UpdateMenuItem :one
UPDATE menu_items
SET 
    category_id = COALESCE($1, category_id),
    name = COALESCE($2, name),
    description = COALESCE($3, description),
    price = COALESCE($4, price),
    images = COALESCE($5, images),
    allergens = COALESCE($6, allergens),
    dietary_tags = COALESCE($7, dietary_tags),
    spice_level = COALESCE($8, spice_level),
    calories = COALESCE($9, calories),
    is_available = COALESCE($10, is_available),
    display_order = COALESCE($11, display_order),
    updated_at = NOW()
WHERE id = $12
RETURNING id, restaurant_id, category_id, name, description, price, currency, images, allergens, dietary_tags, spice_level, calories, is_available, display_order, view_count, created_by, created_at, updated_at
`

type UpdateMenuItemParams struct {
	CategoryID   *uuid.UUID     `db:"category_id" json:"category_id"`
	Name         pgtype.Text    `db:"name" json:"name"`
	Description  pgtype.Text    `db:"description" json:"description"`
	Price        pgtype.Numeric `db:"price" json:"price"`
	Images       []byte         `db:"images" json:"images"`
	Allergens    []byte         `db:"allergens" json:"allergens"`
	DietaryTags  []byte         `db:"dietary_tags" json:"dietary_tags"`
	SpiceLevel   pgtype.Int4    `db:"spice_level" json:"spice_level"`
	Calories     pgtype.Int4    `db:"calories" json:"calories"`
	IsAvailable  pgtype.Bool    `db:"is_available" json:"is_available"`
	DisplayOrder pgtype.Int4    `db:"display_order" json:"display_order"`
	ID           uuid.UUID      `db:"id" json:"id"`
}

func (q *Queries) UpdateMenuItem(ctx context.Context, arg UpdateMenuItemParams) (MenuItem, error) {
	row := q.db.QueryRow(ctx, updateMenuItem,
		arg.CategoryID,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.Images,
		arg.Allergens,
		arg.DietaryTags,
		arg.SpiceLevel,
		arg.Calories,
		arg.IsAvailable,
		arg.DisplayOrder,
		arg.ID,
	)
	var i MenuItem
	err := row.Scan(
		&i.ID,
		&i.RestaurantID,
		&i.CategoryID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.Currency,
		&i.Images,
		&i.Allergens,
		&i.DietaryTags,
		&i.SpiceLevel,
		&i.Calories,
		&i.IsAvailable,
		&i.DisplayOrder,
		&i.ViewCount,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePaymentRetryJob = `-- name: UpdatePaymentRetryJob :one
UPDATE payment_retry_jobs
SET 
    status = $2,
    retry_count = retry_count + 1,
    scheduled_for = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING id, subscription_id, status, retry_count, max_retries, scheduled_for, created_at, updated_at
`

type UpdatePaymentRetryJobParams struct {
	ID           uuid.UUID        `db:"id" json:"id"`
	Status       string           `db:"status" json:"status"`
	ScheduledFor pgtype.Timestamp `db:"scheduled_for" json:"scheduled_for"`
}

func (q *Queries) UpdatePaymentRetryJob(ctx context.Context, arg UpdatePaymentRetryJobParams) (PaymentRetryJob, error) {
	row := q.db.QueryRow(ctx, updatePaymentRetryJob, arg.ID, arg.Status, arg.ScheduledFor)
	var i PaymentRetryJob
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.Status,
		&i.RetryCount,
		&i.MaxRetries,
		&i.ScheduledFor,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePaymentTransactionStatus = `-- name: UpdatePaymentTransactionStatus :one
UPDATE payment_transactions
SET 
    status = $2,
    provider_transaction_ref = COALESCE($3, provider_transaction_ref),
    updated_at = NOW()
WHERE tx_ref = $1
RETURNING id, owner_id, amount, currency, status, tx_ref, reference, provider_transaction_ref, created_at, updated_at
`

type UpdatePaymentTransactionStatusParams struct {
	TxRef                  string      `db:"tx_ref" json:"tx_ref"`
	Status                 string      `db:"status" json:"status"`
	ProviderTransactionRef pgtype.Text `db:"provider_transaction_ref" json:"provider_transaction_ref"`
}

func (q *Queries) UpdatePaymentTransactionStatus(ctx context.Context, arg UpdatePaymentTransactionStatusParams) (PaymentTransaction, error) {
	row := q.db.QueryRow(ctx, updatePaymentTransactionStatus, arg.TxRef, arg.Status, arg.ProviderTransactionRef)
	var i PaymentTransaction
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.TxRef,
		&i.Reference,
		&i.ProviderTransactionRef,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRestaurant = `-- name: UpdateRestaurant :one
UPDATE restaurants
SET 
    name = COALESCE($1, name),
    description = COALESCE($2, description),
    cuisine_type = COALESCE($3, cuisine_type),
    phone = COALESCE($4, phone),
    email = COALESCE($5, email),
    website = COALESCE($6, website),
    address = COALESCE($7, address),
    city = COALESCE($8, city),
    country = COALESCE($9, country),
    logo_url = COALESCE($10, logo_url),
    cover_image_url = COALESCE($11, cover_image_url),
    theme_settings = COALESCE($12, theme_settings),
    is_published = COALESCE($13, is_published),
    updated_at = NOW()
WHERE id = $15 AND (owner_id = $16 OR $17::boolean)
RETURNING id, owner_id, name, slug, description, cuisine_type, phone, email, website, address, city, country, logo_url, cover_image_url, theme_settings, is_published, status, view_count, rank_score, created_at, updated_at
`

type UpdateRestaurantParams struct {
	Name          pgtype.Text          `db:"name" json:"name"`
	Description   pgtype.Text          `db:"description" json:"description"`
	CuisineType   pgtype.Text          `db:"cuisine_type" json:"cuisine_type"`
	Phone         pgtype.Text          `db:"phone" json:"phone"`
	Email         pgtype.Text          `db:"email" json:"email"`
	Website       pgtype.Text          `db:"website" json:"website"`
	Address       pgtype.Text          `db:"address" json:"address"`
	City          pgtype.Text          `db:"city" json:"city"`
	Country       pgtype.Text          `db:"country" json:"country"`
	LogoUrl       pgtype.Text          `db:"logo_url" json:"logo_url"`
	CoverImageUrl pgtype.Text          `db:"cover_image_url" json:"cover_image_url"`
	ThemeSettings []byte               `db:"theme_settings" json:"theme_settings"`
	IsPublished   pgtype.Bool          `db:"is_published" json:"is_published"`
	Status        NullRestaurantStatus `db:"status" json:"status"`
	ID            uuid.UUID            `db:"id" json:"id"`
	OwnerID       uuid.UUID            `db:"owner_id" json:"owner_id"`
	IsAdmin       bool                 `db:"is_admin" json:"is_admin"`
}

func (q *Queries) UpdateRestaurant(ctx context.Context, arg UpdateRestaurantParams) (Restaurant, error) {
	row := q.db.QueryRow(ctx, updateRestaurant,
		arg.Name,
		arg.Description,
		arg.CuisineType,
		arg.Phone,
		arg.Email,
		arg.Website,
		arg.Address,
		arg.City,
		arg.Country,
		arg.LogoUrl,
		arg.CoverImageUrl,
		arg.ThemeSettings,
		arg.IsPublished,
		arg.Status,
		arg.ID,
		arg.OwnerID,
		arg.IsAdmin,
	)
	var i Restaurant
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.CuisineType,
		&i.Phone,
		&i.Email,
		&i.Website,
		&i.Address,
		&i.City,
		&i.Country,
		&i.LogoUrl,
		&i.CoverImageUrl,
		&i.ThemeSettings,
		&i.IsPublished,
		&i.ViewCount,
		&i.RankScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRestaurantStatus = `-- name: UpdateRestaurantStatus :one
UPDATE restaurants
SET status = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, owner_id, name, slug, description, cuisine_type, phone, email, website, address, city, country, logo_url, cover_image_url, theme_settings, is_published, status, view_count, rank_score, created_at, updated_at
`

type UpdateRestaurantStatusParams struct {
	ID     uuid.UUID        `db:"id" json:"id"`
	Status RestaurantStatus `db:"status" json:"status"`
}

func (q *Queries) UpdateRestaurantStatus(ctx context.Context, arg UpdateRestaurantStatusParams) (Restaurant, error) {
	row := q.db.QueryRow(ctx, updateRestaurantStatus, arg.ID, arg.Status)
	var i Restaurant
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.CuisineType,
		&i.Phone,
		&i.Email,
		&i.Website,
		&i.Address,
		&i.City,
		&i.Country,
		&i.LogoUrl,
		&i.CoverImageUrl,
		&i.ThemeSettings,
		&i.IsPublished,
		&i.ViewCount,
		&i.RankScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateStaffStatus = `-- name: UpdateStaffStatus :exec
UPDATE users
SET is_active = $3, updated_at = NOW()
WHERE id = $1 AND restaurant_id = $2 AND role = 'staff'
`

type UpdateStaffStatusParams struct {
	ID           uuid.UUID  `db:"id" json:"id"`
	RestaurantID *uuid.UUID `db:"restaurant_id" json:"restaurant_id"`
	IsActive     bool       `db:"is_active" json:"is_active"`
}

func (q *Queries) UpdateStaffStatus(ctx context.Context, arg UpdateStaffStatusParams) error {
	_, err := q.db.Exec(ctx, updateStaffStatus, arg.ID, arg.RestaurantID, arg.IsActive)
	return err
}

const updateSubscription = `-- name: UpdateSubscription :one
UPDATE subscriptions
SET 
    plan_id = COALESCE($1, plan_id),
    status = COALESCE($2, status),
    current_period_start = COALESCE($3, current_period_start),
    current_period_end = COALESCE($4, current_period_end),
    trial_end = COALESCE($5, trial_end),
    cancelled_at = COALESCE($6, cancelled_at),
    updated_at = NOW()
WHERE id = $7
RETURNING id, owner_id, plan_id, status, current_period_start, current_period_end, trial_end, cancelled_at, payment_provider_subscription_id, created_at, updated_at
`

type UpdateSubscriptionParams struct {
	PlanID             *uuid.UUID             `db:"plan_id" json:"plan_id"`
	Status             NullSubscriptionStatus `db:"status" json:"status"`
	CurrentPeriodStart pgtype.Timestamp       `db:"current_period_start" json:"current_period_start"`
	CurrentPeriodEnd   pgtype.Timestamp       `db:"current_period_end" json:"current_period_end"`
	TrialEnd           pgtype.Timestamp       `db:"trial_end" json:"trial_end"`
	CancelledAt        pgtype.Timestamp       `db:"cancelled_at" json:"cancelled_at"`
	ID                 uuid.UUID              `db:"id" json:"id"`
}

func (q *Queries) UpdateSubscription(ctx context.Context, arg UpdateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, updateSubscription,
		arg.PlanID,
		arg.Status,
		arg.CurrentPeriodStart,
		arg.CurrentPeriodEnd,
		arg.TrialEnd,
		arg.CancelledAt,
		arg.ID,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.PlanID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.TrialEnd,
		&i.CancelledAt,
		&i.PaymentProviderSubscriptionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET 
    full_name = COALESCE($1, full_name),
    phone = COALESCE($2, phone),
    avatar_url = COALESCE($3, avatar_url),
    email_verified = COALESCE($4, email_verified),
    last_login_at = COALESCE($5, last_login_at),
    is_active = COALESCE($6, is_active),
    updated_at = NOW()
WHERE id = $7
RETURNING id, email, password_hash, full_name, role, owner_id, restaurant_id, phone, avatar_url, email_verified, last_login_at, is_active, created_at, updated_at,  email_verified_at, verification_token, verification_token_expires_at, trial_ends_at
`

type UpdateUserParams struct {
	FullName      pgtype.Text      `db:"full_name" json:"full_name"`
	Phone         pgtype.Text      `db:"phone" json:"phone"`
	AvatarUrl     pgtype.Text      `db:"avatar_url" json:"avatar_url"`
	EmailVerified pgtype.Bool      `db:"email_verified" json:"email_verified"`
	LastLoginAt   pgtype.Timestamp `db:"last_login_at" json:"last_login_at"`
	IsActive      pgtype.Bool      `db:"is_active" json:"is_active"`
	ID            uuid.UUID        `db:"id" json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.FullName,
		arg.Phone,
		arg.AvatarUrl,
		arg.EmailVerified,
		arg.LastLoginAt,
		arg.IsActive,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.Role,
		&i.OwnerID,
		&i.RestaurantID,
		&i.Phone,
		&i.AvatarUrl,
		&i.EmailVerified,
		&i.LastLoginAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EmailVerifiedAt,
		&i.VerificationToken,
		&i.VerificationTokenExpiresAt,
		&i.TrialEndsAt,
	)
	return i, err
}

const upsertAnalyticsAggregate = `-- name: UpsertAnalyticsAggregate :one
INSERT INTO analytics_aggregates (
    restaurant_id, date, hour, metric_type, target_id, value
) VALUES (
    $1, $2, $3, $4, $5, $6
) ON CONFLICT (restaurant_id, date, hour, metric_type, target_id)
DO UPDATE SET 
    value = analytics_aggregates.value + EXCLUDED.value,
    updated_at = NOW()
RETURNING id, restaurant_id, date, hour, metric_type, target_id, value, created_at, updated_at
`

type UpsertAnalyticsAggregateParams struct {
	RestaurantID uuid.UUID   `db:"restaurant_id" json:"restaurant_id"`
	Date         pgtype.Date `db:"date" json:"date"`
	Hour         pgtype.Int4 `db:"hour" json:"hour"`
	MetricType   string      `db:"metric_type" json:"metric_type"`
	TargetID     *uuid.UUID  `db:"target_id" json:"target_id"`
	Value        pgtype.Int4 `db:"value" json:"value"`
}

func (q *Queries) UpsertAnalyticsAggregate(ctx context.Context, arg UpsertAnalyticsAggregateParams) (AnalyticsAggregate, error) {
	row := q.db.QueryRow(ctx, upsertAnalyticsAggregate,
		arg.RestaurantID,
		arg.Date,
		arg.Hour,
		arg.MetricType,
		arg.TargetID,
		arg.Value,
	)
	var i AnalyticsAggregate
	err := row.Scan(
		&i.ID,
		&i.RestaurantID,
		&i.Date,
		&i.Hour,
		&i.MetricType,
		&i.TargetID,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
